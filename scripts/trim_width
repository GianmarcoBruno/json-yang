#!/usr/bin/perl -ws

use strict;
use Tie::File;

# takes a JSON pseudo-comment line of this form:
# <trailing spaces>"//<spaces><comment key>"<spaces>:<spaces>"<comment value>"
# and rewrites it as:
# <trailing spaces>"//<one space><comment key>":<one space>"<comment 1>",
# <trailing spaces>"//<one space><comment key>":<one space>"<comment 2>",
# and so on to fit the given width.

sub split_line {
    my ($line, $width) = @_;

    $line =~ /^(\s*)"\/\/(\s*)(.*)"(\s*):(\s*)"(.*)"/;
    my ($leading_spaces, $key, $value) = ($1, $3, $6);
    my $ends_with_comma = ($line =~ /,$/);

    # first 4 chars are '"// ', second 4 chars are '": "'
    my $value_start = (length $leading_spaces) + 4 + (length $key) + 4;
    die "Pseudo-comment key: $key too long to be fit within $width chars. Rephrase text"
	if ($value_start > $width);

    my @words = split " ", $value;
    my $split_value = shift @words;
    my $avail_space = $width - $value_start;
    die "Pseudo-comment value: cannot break $value to be fit within $width chars. Rephrase text"
	if (length($split_value) > $avail_space);

    my @out;
    my %seen;
    my $key_value_line;
    while (my $word = shift @words) {
	if ((length $split_value) + 1 + (length $word) + 1 < $avail_space) {
	    $split_value = join(' ', $split_value, $word);
	} else {
	    die "Pseudo-comment value: cannot break $value to be fit within $width chars. Rephrase text"
		if $seen{$word};
	    $key_value_line = $leading_spaces . _w("// " . $key) . ": " . _w($split_value);
	    $key_value_line = join ('', $key_value_line, ',');
	    push @out, $key_value_line;
	    unshift @words, $word;
	    $seen{$word} = 1;
	    $split_value = "";
	}
    }
    $key_value_line = $leading_spaces . _w("// " . $key) . ": " . _w($split_value);
    $key_value_line = join ('', $key_value_line, ',');
    push @out, $key_value_line;

    # comma always added so far. Remove it from last output line if not required
    $out[-1] =~ s/,$// unless ($ends_with_comma);

    return @out;
}


# we split a non-comment line in a line for the key and another for the value
sub split_nc_line {
    my ($line, $width, $indent) = @_;

    $line =~ /^(\s*)"(\s*)(.*)"(\s*):(\s*)"(.*)"/;
    my ($leading_spaces, $key, $value) = ($1, $3, $6);
    my $ends_with_comma = ($line =~ /,$/);

    my $key_line = $leading_spaces . _w($key) . ":";
    my $value_line = " " x $indent . $leading_spaces . _w($value);
    $value_line = join ('', $value_line, ',') if ($ends_with_comma);

    my @out = ($key_line);
    push @out, $value_line;
    return @out;
}

sub _w {
    my ($x) = @_;
    return '"' . $x . '"';
}

sub is_comment {
    my ($str) = @_;
    return ($str =~ /^(\s*)"\/\//) ? 1 : 0;
}

sub help {
    my $str = <<'MSG';
usage: trim_width [-w <WIDTH>] [-i <INDENT>] <FILE>
Rearrange the contents of the given <FILE> including JSON pseudo-comments by 
wrapping them to fit the given page <WIDTH>.
JSON pseudo-comments are key-value pairs where the key starts with "//".
If <WIDTH> is not given, the RFCs standard width 72 is used.
Long non-comment lines are split and the second line is indented by <INDENT>
spaces, 2 if not specified.
MSG
    print "\n$str\n";
    exit 1;
}

use vars qw($w $i);
$w ||= 72;
$i ||= 2;
my $file = $ARGV[0] || help();

tie my @array, 'Tie::File', $file or die "cannot open $file";

my $line_number = 0; # changes in flight!
while (my $line = $array[$line_number]) {
    chomp $line;
    $line =~ s/\r//;
    if ((length $line) > $w) {
	if (is_comment($line)) {
	    my @new_lines = split_line($line, $w);
	    splice @array, $line_number, 1, @new_lines;
	    $line_number += scalar(@new_lines) - 1;
	} else {
	    #warn "splitting non-comment line longer than $w";
	    # try basic split
	    my @new_lines = split_nc_line($line, $w, $i);
	    splice @array, $line_number, 1, @new_lines;
	    $line_number += scalar(@new_lines) - 1;
	}
    }
    $line_number += 1;
}

# final check
my %too_long;
my $i = 0;
for my $line (@array) {
    $too_long{$i} = $line if (length($line) > $w);
    $i += 1;
}
if (%too_long) {
    print "Lines exceeding $w chars:\n";
    map { print $_ . " : " . $too_long{$_} . "\n" } keys %too_long;
} else {
    print "All lines are now <= $w chars long\n";
}
